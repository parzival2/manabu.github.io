[{"content":"Cross-compiler using crosstool-ng for Beaglebone In the previous post, I have used an already available cross-compiling compiler to cross-compile a C++ project for Beaglebone. I want to learn how I can do that so that I can utilize the learned knowledge if the need arises. I came to know that we can build a compiler using a tool called crosstool-ng. I am going to use it to build a compiler that can be used to cross-compile C and C++ applications for Beaglebone.\nBuilding crosstool-ng The crosstool-ng has to be built as an application before it can be used to build the compiler. When built, it will produce an executable ct-ng that can be used to build the final compiler.\ngit clone https://github.com/crosstool-ng/crosstool-ng cd crosstool-ng ./bootstrap ./configure --enable-local make After running the above commands, you will see that they have produced an executable ct-ng.\nGenerate the configuration for ARM cortex A8 processor using ct-ng\n./ct-ng arm-cortex_a8-linux-gnueabi Run menuconfig to edit the configurations\n./ct-ng menuconfig Make changes in Paths and misc options as shown below\n and also make changes in Target options to enable hard-floating point calculation capability.\n Exit and build the compiler using\n./ct-ng build It will take ~20minutes and if you have followed everything correctly then the build should succeed and you will have a folder in ~/x-tools and the compiler will be in ~/x-tools/arm-cortex_a8-linux-gnueabihf/bin\nAs you can see you didn\u0026rsquo;t change any configurations related to the compiler version and the Linux version on Beaglebone. The compiler you generated will not work if it depends on the libraries that are on Beaglebone and you would like to use mount the file-system using sshfs for sysroot as mentioned in the previous post.\nBeaglebone side Before we can build the compiler on the host-pc, we need to gather some data on the Beaglebone side. It is important that the GCC compiler that we are trying to build and the one that we have on the Beaglebone match. The GCC compiler on the Beaglebone can be found by using the command:\ndebian@beaglebone:~$ gcc -v Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper Target: arm-linux-gnueabihf Configured with: ../src/configure -v --with-pkgversion=\u0026#39;Debian 8.3.0-6\u0026#39; --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv7-a --with-fpu=vfpv3-d16 --with-float=hard --with-mode=thumb --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf Thread model: posix gcc version 8.3.0 (Debian 8.3.0-6) Mine turned out to be 8.3.0\nNext we need to find the GLIBC version\ndebian@beaglebone:~$ ldd --version ldd (Debian GLIBC 2.28-10) 2.28 Then binutils version\ndebian@beaglebone:~$ ld --version GNU ld (GNU Binutils for Debian) 2.31.1 Copyright (C) 2018 Free Software Foundation, Inc. We also need the current Linux version that our Beaglebone have\nuname -a Linux beaglebone 4.19.94-ti-rt-r60 #1buster SMP PREEMPT RT Wed Mar 17 16:22:33 UTC 2021 armv7l GNU/Linux If you see the command where we determined gcc -v you will notice that --enable-multiarch has been enabled. This makes it to have another folder named arm-linux-gnueabihf in the /usr/include and /usr/lib folders as seen below\n/usr/lib/ ├── apt │ ├── methods │ ├── planners │ └── solvers ├── arm-linux-gnueabihf │ ├── audit │ ├── coreutils The cross-compiler that we are building needs to know that it has to look for some includes and libraries in that folder. This can be solved by applying a patch in binutils while building it using crosstool-ng.\nInstall the source for binutils on Beaglebone\nsudo apt install binutils-source Patching binutils Applying a patch for binutils is as simple as copying the patch from Beaglebone over to the host-pc.\nAs you have already installed the binutils-source the patches are also installed. The source can be found in /usr/src/binutils on Beaglebone. In patches folder, copy and paste the 129_multiarch_libpath.patch in /crosstool-ng/packages/binutils/2.31.1/. Please replace the 2.31.1 with the version that you determined by running ld --version in one of the previous step.\nBack to host-pc and finishing compilation Now we are back to the host-pc for finishing up the compilation. We need to configure all the versions of the tools according to the versions that we determined in Beaglebone so as to avoid linker errors.\nRun ./ct-ng menuconfig to bring up the configuration window.\nIn Operating System change the version of Linux that closely corresponds to the Linux version of Beaglebone. I am going with 4.18.20\n Next in Binary utilities section, change the version of binutils that is going to be used for the build. This has to correspond with the version that was determined earlier in Beaglebone.\n Moving on to C-library, change the glibc version to match with the version from Beaglebone.\n Now in C compiler, change the version of gcc to closely correspond to the version that is found in Beaglebone and also in gcc extra config add --enable-multiarch option as shown below.\n Run\nexport DEB_TARGET_MULTIARCH=arm-linux-gnueabihf Now build the toolchain again using ./ct-ng build.\nIf you run\n./arm-cortex_a8-linux-gnueabihf-ld -verbose | grep -i \u0026#34;SEARCH\u0026#34; from the compiler installation folder in ~/x-tools you will see that it also searches for arm-linux-gnueabihf folder.\nSEARCH_DIR(\u0026#34;=/usr/local/lib/arm-linux-gnueabihf\u0026#34;); SEARCH_DIR(\u0026#34;=/lib/arm-linux-gnueabihf\u0026#34;); SEARCH_DIR(\u0026#34;=/usr/lib/arm-linux-gnueabihf\u0026#34;); SEARCH_DIR(\u0026#34;=/usr/local/lib\u0026#34;); SEARCH_DIR(\u0026#34;=/lib\u0026#34;); SEARCH_DIR(\u0026#34;=/usr/lib\u0026#34;); SEARCH_DIR(\u0026#34;=/home/kalyan/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/lib\u0026#34;); You can use the generated compiler using this toolchain file.\n# Set the system name set(CMAKE_SYSTEM_NAME Linux)# C Compiler set(COMPILER_PATH /home/kalyan/x-tools/arm-cortex_a8-linux-gnueabihf/bin)set(COMPILER_FRONT arm-cortex_a8-linux-gnueabihf-)set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)set(CMAKE_C_COMPILER ${COMPILER_PATH}/${COMPILER_FRONT}gcc)set(CMAKE_CXX_COMPILER ${COMPILER_PATH}/${COMPILER_FRONT}g++)# Sysroot location # It is mounted using sshfs set(CMAKE_SYSROOT /home/kalyan/Beaglebone-Sysroot)# These lines are necessary to let cmake know to only look in the # beaglebone for the libraries instead of looking in host pc. # sshfs debian@192.168.7.2:/ /home/kalyan/Beaglegone-Sysroot/ -o transform_symlinks set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)","permalink":"https://parzival2.github.io/blog/posts/crosstool-ng-beaglebone/","summary":"Cross-compiler using crosstool-ng for Beaglebone In the previous post, I have used an already available cross-compiling compiler to cross-compile a C++ project for Beaglebone. I want to learn how I can do that so that I can utilize the learned knowledge if the need arises. I came to know that we can build a compiler using a tool called crosstool-ng. I am going to use it to build a compiler that can be used to cross-compile C and C++ applications for Beaglebone.","title":"Cross-compiler using crosstool-ng for Beaglebone"},{"content":"Cross compiling a C++ project for Beaglebone I am thinking of getting into Embedded Linux, so I have ordered a Beaglebone. I don\u0026rsquo;t want to use Python to program it as I want to do some real-time processing with it. For that, I have to figure out how to compile C++ programs on the host PC instead of doing it on the Beaglebone as it has very little ram.\nInitially, I wanted to do the cross-compilation using QEMU but quickly gave up the idea as there is no out-of-the-box QEMU system for Beaglebone. Raspberry pi has a nice QEMU system that runs out of the box. I will revisit the idea of using QEMU once I got accompanied on the procedure on building Linux kernel. Everything new has to start simple, so, a simple that I have in mind is to compile and run a LED blinking application using libgpiod library which is the preferred method for driving GPIOs from user-space.\nI built and installed the libgpiod library on the Beaglebone itself. I can also install it using sudo apt install libgpiod but I don\u0026rsquo;t want to do that as it was a very old version.\nCompiling and installing libgpiod The libgpiod library can be built and installed using the following procedure.\ngit clone https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/ You will checkout the master branch. Feel free to checkout a release if you are more comfortable like that using\ngit checkout remotes/origin/v1.6.x Configure and compile it using the following commands\n./autogen.sh --enable-tools=yes --enable-bindings-cxx=yes --prefix=/usr/local make sudo make install If you don\u0026rsquo;t want to use C++, then remove the --enable-bindings-cxx=yes in the above command lines.\nThe libgpiod comes with a bunch of useful command line tools for driving and testing GPIOs.\nAll the commands take offset along with the gpiochip number that, that GPIO refers to.\nE.g. If you want to drive P9-12 pin on the Beaglebone-Black then you would set the offset to 28 and the gpiochip as gpiochip1\ngpioset gpiochip1 28=1 CMAKE_SYSROOT and sshfs To cross-compile a C++ project, CMake needs to find the libraries in the target. The CMAKE_SYSROOT variable will be used to let the CMake know where the target system libraries are located in. I thought of using rsync to copy the required libraries from Beaglebone to the host PC, but, I used sshfs to mount the Beaglebone root folder in the host pc.\ncd ~ mkdir Beaglebone-Sysroot sshfs debian@192.168.7.2:/ /home/kalyan/Beaglebone-Sysroot/ -o transform_symlinks /home/kalyan/Beaglebone-Sysroot/ path needs to be the folder that you have created and it will be used as a mount point where the root file system of beaglebone will be mounted.\nInstalling Cross-compiler I installed the cross-compiler using sudo apt install crossbuild-essential-armhf because the compiler that I downloaded from the GNU website doesn\u0026rsquo;t has the correct sysroot setup and the builds were failing.\nCMake toolchain file This is the CMake toolchain file that I am using\n# Set the system name set(CMAKE_SYSTEM_NAME Linux)# C Compiler set(CMAKE_C_COMPILER /usr/bin/arm-linux-gnueabihf-gcc)set(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabihf-g++)# Sysroot location # It is mounted using sshfs set(CMAKE_SYSROOT /home/kalyan/Beaglebone-Sysroot)# These lines are necessary to let cmake know to only look in the # beaglebone for the libraries instead of looking in host pc. # sshfs debian@192.168.7.2:/ /home/kalyan/Beaglegone-Sysroot/ -o transform_symlinks set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)The project can be found in github.\n","permalink":"https://parzival2.github.io/blog/posts/beaglebone-cross-compile/","summary":"Cross compiling a C++ project for Beaglebone I am thinking of getting into Embedded Linux, so I have ordered a Beaglebone. I don\u0026rsquo;t want to use Python to program it as I want to do some real-time processing with it. For that, I have to figure out how to compile C++ programs on the host PC instead of doing it on the Beaglebone as it has very little ram.\nInitially, I wanted to do the cross-compilation using QEMU but quickly gave up the idea as there is no out-of-the-box QEMU system for Beaglebone.","title":"Cross compile C++ project for beaglebone"},{"content":"Sharing internet connection with Beaglebone The beaglebone can be connected over serial and the fun part is that the usb post emulates the lan connection. So we don\u0026rsquo;t need to have another lan connection to ssh into the board.\nThe present versions the debian seems to recognize the SD card and boot from the SD Card directly. The instructions seem to suggest that we should hold the USERBUTTON while providing power in-order to boot from SD Card.\nConnect the Beaglebone with the USB Micro and wait for sometime to let the Debian image to boot.\nHost In order to check the device you can enter\nifconfig\nIt should look something like this\nenx402e71cff462: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.7.1 netmask 255.255.255.0 broadcast 192.168.7.255 inet6 fe80::91d8:e48:fa2e:b206 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 40:2e:71:cf:f4:62 txqueuelen 1000 (Ethernet) RX packets 86 bytes 11773 (11.7 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 149 bytes 29354 (29.3 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 . . . wlo1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.0.157 netmask 255.255.255.0 broadcast 192.168.0.255 The important information that we need is enx402e71cff462 and wlo1. Take a note of that we will be using it in a few minutes.\nEnter these lines in the terminal. Make sure to use the device ID that you have by typing ifconfig\nsudo ifconfig enx402e71cff462 192.168.7.1 sudo sysctl net.ipv4.ip_forward=1 sudo iptables --table nat --append POSTROUTING --out-interface wlo1 -j MASQUERADE sudo iptables --append FORWARD --in-interface enx402e71cff462 -j ACCEPT Beaglebone On the beaglebone side, enter these commands.\nsudo route add default gw 192.168.7.1 echo \u0026#34;nameserver 8.8.8.8\u0026#34; \u0026gt;\u0026gt; /etc/resolv.conf Thats it. You should have the Internet on Beaglebone.\n","permalink":"https://parzival2.github.io/blog/posts/beaglebone-internet/","summary":"Sharing internet connection with Beaglebone The beaglebone can be connected over serial and the fun part is that the usb post emulates the lan connection. So we don\u0026rsquo;t need to have another lan connection to ssh into the board.\nThe present versions the debian seems to recognize the SD card and boot from the SD Card directly. The instructions seem to suggest that we should hold the USERBUTTON while providing power in-order to boot from SD Card.","title":"Sharing internet connection with Beaglebone"},{"content":"I want to get into programming Blue-pill using libopencm3 and FreeRTOS. To get started I wanted to compile few test programs to get the feel for it. I needed a flasher as the small board doesn\u0026rsquo;t have an inbuilt programmer like STM32F4Discovery\nST-Link I have ordered a cheap ST-Link that I have found online specifically this. The pinout for this one is\n  Bluepill The bluepill connections are as follows from the top right    Pin     GND   CLK   SDIO   3V3   So you just have to connect them according to the name of the pin.    3V3\t-\u0026gt;\t3V3 SDIO\t-\u0026gt;\tSDIO CLK\t-\u0026gt;\tCLK GND\t-\u0026gt;\tGND After they are connected properly, the LED should start blinking. There is already a blinking program on all the boards.\nFlashing For flashing you can use either OpenOCD or stlink-utils. You can also check the flash size by using st-info --probe. I got an output like this after the connections are done properly.\nFound 1 stlink programmers serial: 303030303030303030303031 openocd: \u0026quot;\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x30\\x31\u0026quot; flash: 131072 (pagesize: 1024) sram: 20480 chipid: 0x0410 descr: F1 Medium-density device To embed Flickr images I followed this link.\n","permalink":"https://parzival2.github.io/blog/posts/flashing-bluepill.md/","summary":"I want to get into programming Blue-pill using libopencm3 and FreeRTOS. To get started I wanted to compile few test programs to get the feel for it. I needed a flasher as the small board doesn\u0026rsquo;t have an inbuilt programmer like STM32F4Discovery\nST-Link I have ordered a cheap ST-Link that I have found online specifically this. The pinout for this one is\n  Bluepill The bluepill connections are as follows from the top right    Pin     GND   CLK   SDIO   3V3   So you just have to connect them according to the name of the pin.","title":"Flashing bluepill using ST-Link board"},{"content":"I have an orangepi zero that I want to connect to a ROS instance running on my desktop to play around with manual control on PX4. I have followed some instructions here but they appear not to work for me. The orangepi always says that there is no roscore running. I searched and searched and I came across this page that seems to provide correct instructions. I did it like in the below-mentioned procedure and the orange pi seems to recognize the ROS instance running on my desktop.\nMaster export ROS_MASTER_URI=http://192.168.0.157:11311 export ROS_IP=192.168.0.157 roscore Orange pi export ROS_MASTER_URI=http://192.168.0.157:11311 export ROS_IP=192.168.0.207 rostopic list and now I get\n/rosout /rosout_agg You can also put the first two lines in ~/.bashrc but then you have to have a static IP address for both the machines.\n","permalink":"https://parzival2.github.io/blog/posts/ros-multiple-machines/","summary":"I have an orangepi zero that I want to connect to a ROS instance running on my desktop to play around with manual control on PX4. I have followed some instructions here but they appear not to work for me. The orangepi always says that there is no roscore running. I searched and searched and I came across this page that seems to provide correct instructions. I did it like in the below-mentioned procedure and the orange pi seems to recognize the ROS instance running on my desktop.","title":"ROS connection between multiple machines on LAN"},{"content":"Adding images in Hugo I had a lot of trouble adding images in Hugo and searched a lot on the internet and finally solved the problem. The thanks go to the comment under an issue.\nThe secret is to store the images in the static folder and also follow the correct directory structure. If we take this page as an example, the images are added into static\\posts\\qtcreator-ros\\ folder to mimic the search path.\nSo the path should be static\\posts\\\u0026lt;Your Post name\u0026gt;\\image.png and you can link it in your page as follows\n![Title of image](image.png) Notice there is no path before the image name.\nThe folders on my computer looks as follows for the above mentioned example\nStatic └── posts └── qtcreator-ros \u0026lt;- Notice the name of the post └── qtcreator-buildfolder.png Content ├── archives.md ├── posts │ ├── add-images-hugo.md │ ├── mathtypesetting.md │ ├── qtcreator-ros.md \u0026lt;- The image will be linked in this post. │ └── rich-content.md └── search.md ","permalink":"https://parzival2.github.io/blog/posts/add-images-hugo/","summary":"Adding images in Hugo I had a lot of trouble adding images in Hugo and searched a lot on the internet and finally solved the problem. The thanks go to the comment under an issue.\nThe secret is to store the images in the static folder and also follow the correct directory structure. If we take this page as an example, the images are added into static\\posts\\qtcreator-ros\\ folder to mimic the search path.","title":"Adding images in Hugo"},{"content":"I have tried many IDEs and found that QtCreator is the one that I like. So I wanted to setup QtCreator for ROS development.\nPrerequisites Installing ROS I assume that you have already installed ROS on your operating system. If not you can follow these instructions\nInstalling QtCreator An open-sourced version of QtCreator can be downloaded from here. From here you can only download QtCreator IDE without downloading the Qt framework.\nCreate Workspace and Compiling Our Package Create a catkin-workspace if you haven\u0026rsquo;t done so by running\nmkdir catkin_ws cd catkin_ws mkdir src catkin_make Then create a package using\ncatkin_create_pkg package_name std_msgs roscpp Finally compile the package using\ncatkin_make Setting up QtCreator Actually, there is little to setup. The QtCreator works with ROS out of the box but I had some trouble. It also messes up the ROS build environment too which will have been created using catkin-make. For this step to work, we need to build the project at least once so that QtCreator can find the correct build folders. For QtCreator to load the environment variables provided in ~/.bashrc, we need to launch it by creating a custom .desktop file.\nPaste the following contents in to a file on the desktop named appropriately, QtCreator.desktop\n[Desktop Entry] Type=Application Exec=bash -i -c \u0026quot;/home/kalyan/Qt/Tools/QtCreator/bin/qtcreator\u0026quot; %F Name=Qt Creator GenericName=The IDE of choice for Qt development. Icon=QtProject-qtcreator StartupWMClass=qtcreator Terminal=false Categories=Development;IDE;Qt; MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.qt.qmakeprofile;application/vnd.qt.xml.resource;text/x-qml;text/x-qt.qml;text/x-qt.qbs; Right-click on the created file and choose Allow Launching.\nI guess this is a new addition in Ubuntu20.04. As soon as you do that, you can launch QtCreator by double-clicking on it.\nLaunch the QtCreator and open the CMakeLists.txt in ~catkin_ws\\src folder.\nNow, de-select all the Temporary Kit and select the QtDesktop Kit that you have already setup.\nSetup the build type of your choice and most importantly select the build folder found in your workspace as the path to the build folder as shown in the following screenshot.\n References Qt\nROS\nROS IDEs\n","permalink":"https://parzival2.github.io/blog/posts/qtcreator-ros/","summary":"I have tried many IDEs and found that QtCreator is the one that I like. So I wanted to setup QtCreator for ROS development.\nPrerequisites Installing ROS I assume that you have already installed ROS on your operating system. If not you can follow these instructions\nInstalling QtCreator An open-sourced version of QtCreator can be downloaded from here. From here you can only download QtCreator IDE without downloading the Qt framework.","title":"QtCreator with ROS"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\nExamples Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"https://parzival2.github.io/blog/posts/mathtypesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"}]